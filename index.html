<!doctype html>
<!--[if lt IE 7]>      <html lang="en" class="ie6"> <![endif]-->
<!--[if IE 7]>         <html lang="en" class="ie7"> <![endif]-->
<!--[if IE 8]>         <html lang="en" class="ie8"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en">         <!--<![endif]-->
  <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="description" content="">
      <meta name="viewport" content="width=device-width, initial-scale=1">

      <title>BBStrap - Bootstrap your backbone application</title>

      <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">

      <style type="text/css">
        body {
          padding-top: 70px;
        }

        h4 {
          margin-top: 30px;
        }

        .jumbotron,
        .content {
          width: 90%;
          margin: auto;
        }

        .panel {
          margin-top: 20px;
        }

        .panel-heading {
          font-size: 20px;
          cursor: pointer;
          padding-left: 50px;
          background-image: url(images/no-expand.png);
          background-repeat: no-repeat;
          background-position: 1% 50%;
        }

        .panel-heading.off {
          background-image: url(images/expand.png);
        }

        .italic {
          font-style: italic;
        }
      </style>
  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Backbone Strap</a>
        </div>

        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#home">Home</a></li>
            <li><a href="#mediator">Mediator</a></li>
            <li><a href="#templates">Template Manager</a></li>
            <li><a href="#views">Views</a></li>
            <li><a href="#models">Models</a></li>
            <li><a href="#collections">Collections</a></li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="jumbotron">
      <h1>Backbone Strap</h1>
      <p>v0.1.0</p>
      <p class="small italic">Simple Backbone Framework used to bootstrap your application</p>
      <p>
        <a class="btn btn-primary" href="https://github.com/mjeanroy/bb-strap">View on GitHub»</a>
        <a class="btn btn-success" href="https://github.com/mjeanroy/bb-strap/tags">Download»</a>
      </p>
    </div>

    <div class="content">
      <div id="home" class="panel panel-default">
        <div class="panel-heading">Info</div>
        <div class="panel-body">
          <h3>Goal</h3>
          <p>
            The main goal of Backbone-Strap is:
            <ul>
              <li>Eliminate necessary boilerplate used to develop backbone applications.</li>
              <li>Avoid memory leak that can occur with backbone applications.</li>
              <li>Share common pattern to develop backbone applications.</li>
            </ul>
            If Backbone-Strap does not fit your needs, feel free to submit an issue or use an other awesome backbone framework (such as <a href="http://marionettejs.com/">Marionette</a> or <a href="https://github.com/tbranyen/backbone.layoutmanager">Layout Manager</a>).
          </p>

          <h3>Browser Compatibility</h3>
          <p>
            Backbone Strap should work with majority of browsers including:
            <ul>
              <li>IE 7+</li>
              <li>Firefox 3.5+</li>
              <li>Google Chrome</li>
              <li>Safari</li>
              <li>Opera</li>
            </ul>
          </p>

          <h3>License</h3>
          <p>
            Backbone Strap is licensed under the <a href="http://opensource.org/licenses/MIT">MIT license</a>.
          </p>

          <h3>Credits</h3>
          <p>
            Backbone Strap is developed and maintained by <a href="https://twitter.com/mickaeljeanroy">@mickaeljeanroy</a>.
          </p>
        </div>
      </div>

      <div id="mediator" class="panel panel-default">
        <div class="panel-heading">Mediator</div>
        <div class="panel-body">
          <p>
            A mediator object is automatically created and it lets you broadcast / subscribe to custom events. Note that the mediator is a singleton and the same instance
            is used everywhere.
            <table class="table table-stripped table-bordered docs">
              <tbody>
                <tr>
                  <td><code>subscribe</code></td>
                  <td>function</td>
                  <td>Subscribe to an event.</td>
                </tr>
                <tr>
                  <td><code>sub</code></td>
                  <td>function</td>
                  <td>Alias to <code>subscribe</code> method.</td>
                </tr>
                <tr>
                  <td><code>subscribeOnce</code></td>
                  <td>function</td>
                  <td>Subscribe to an event only once (event is automatically unsubscribed after first broadcast).</td>
                </tr>
                <tr>
                  <td><code>publish</code></td>
                  <td>function</td>
                  <td>Publish event.</td>
                </tr>
                <tr>
                  <td><code>pub</code></td>
                  <td>function</td>
                  <td>Alias to <code>publish</code> method.</td>
                </tr>
                <tr>
                  <td><code>unsubscribe</code></td>
                  <td>function</td>
                  <td>Clear a specific subscriptions.</td>
                </tr>
                <tr>
                  <td><code>clear</code></td>
                  <td>function</td>
                  <td>Clear all subscriptions.</td>
                </tr>
              </tbody>
            </table>
          </p>

<pre>
var mediator = Backbone.Mediator;

var callback = function() {};
var context = this;

// Subscribe to an event
mediator.subscribe(
  'foo',    // First parameter is the name of the event.
  callback, // Second parameter is the callback to execute when event is broadcasted.
  context   // Third parameter is the context (a.k.a this) of callback (optional).
);

// Subscribe to an event
mediator.subscribeOnce(
  'foo',    // First parameter is the name of the event.
  callback, // Second parameter is the callback to execute when event is broadcasted.
  context   // Third parameter is the context (a.k.a this) of callback (optional).
);

// Unsubscribe
mediator.unsubscribe(
  'foo',    // First parameter is the name of the event to unsubscribe.
  callback, // Second parameter is the callback to unsubscribe (optional, by default all subscriptions are removed).
  context,  // Third parameter is the context that was given at subscription.
);

// Clear subscriptions
mediator.clear();

// Clear subscriptions
mediator.publish(
  'foo', // Event to broadcast
  1, 2   // Parameters to given to callbacks
);
</pre>
        </div>
      </div>

      <div id="templates" class="panel panel-default">
        <div class="panel-heading">Template Manager</div>
        <div class="panel-body">
          <p>Backbone Strap provide a really simple manager that can be used to fetch remote template.</p>
          <p>
            By default, each template will be loaded with a prefix and suffix value. It means that when template 'foo' is fetched, url that will be fetched is:
            <code>[prefix]foo[suffix]</code>
          </p>
          <p>Note that template manager provide out of the box a cache of templates (template will be fetched only once).</code></p>
          <p>
            <table class="table table-stripped table-bordered">
              <tbody>
                <tr>
                  <td><code>prefix</code></td>
                  <td>property</td>
                  <td>Prefix prepended to template url. Default value is <code>/templates/</code></td>
                </tr>
                <tr>
                  <td><code>suffix</code></td>
                  <td>property</td>
                  <td>Suffix appended to template url. Default value is <code>.template.html</code></td>
                </tr>
                <tr>
                  <td><code>load</code></td>
                  <td>function</td>
                  <td>Load a single template and trigger callback. If an array of templates is fetched, <code>loads</code> function will be executed instead.</td>
                </tr>
                <tr>
                  <td><code>loads</code></td>
                  <td>function</td>
                  <td>Load an array of templates and trigger callback when every templates have been loaded.</td>
                </tr>
              </tbody>
            </table>
          </p>
<pre>
// Access default template
var templateManager = Backbone.templateManager;

// Create new template
var templateManager = new Backbone.TemplateManager();

// Create new template manager and override prefix and suffix properties
var templateManager = new Backbone.TemplateManager({
  prefix: '/foo',
  suffix: '.html'
});

// Load a single template and execute given callback
// URL that will be fetched is: /templates/foo.template.html
templateManager.load('foo', function(html) {
  console.log(html);
});

// Load a single template and execute given callback with given context (a.k.a 'this' value of callback)
// URL that will be fetched is: /templates/foo.template.html
templateManager.load('foo', function(html) {
  console.log(html);
}, this);

// Load a single template and execute given callback
// URL that will be fetched are:
//  /templates/foo.template.html
//  /templates/bar.template.html
templateManager.load(['foo', 'bar'], function(html) {
  // html parameter is a map of templates:
  console.log(html['foo']);
  console.log(html['bar']);
});

// Load a single template and execute given callback with given context (a.k.a 'this' value of callback)
// URL that will be fetched are:
//  /templates/foo.template.html
//  /templates/bar.template.html
templateManager.load(['foo', 'bar'], function(html) {
  // html parameter is a map of templates:
  console.log(html['foo']);
  console.log(html['bar']);
}, this);
</pre>
        </div>
      </div>

      <div id="views" class="panel panel-default">
        <div class="panel-heading">Views</div>
        <div class="panel-body">
          <p>Backbone Strap provide new object <code>StrapView</code> with new feature.</p>

          <h3>Constructor</h3>
          <p>Parameter given during object initialization are automatically set on object.</p>
          <p>It means that you don't need <code>initialize</code> anymore !</p>
<pre>
var view = new Backbone.StrapView({
  foo: 'bar'
});

console.log(view.foo); // 'bar'
</pre>

          <h3>Initialization</h3>
          <p>
            When view is initialized, Backbone Strap will check if view is already rendered (view can be rendered server side) and execute different callbacks:
            <ol>
              <li>Like any other Backbone application, <code>initialize</code> function is (always) executed.</li>
              <li>A new callbacl is added and <code>onInit</code> function will be (always) executed after <code>initialize</code> function.</li>
              <li>
                Backbone Strap will then check if view is empty:
                <ul>
                  <li>
                    If view is empty, <code>postInit</code> function is executed.<br>
                    By default, this function do nothing and should be overriden with your own logic (probably fetch models or collections).
                  </li>
                  <li>
                    If view is not empty, <code>onReady</code> function is executed.
                    By default, this function do nothing and should be overriden with your own logic (probably initialize jQuery plugins or something else).
                  </li>
                </ul>
              </li>
            </ol>
              Note that Backbone Strap functions (<code>onInit</code>, <code>postInit</code> and <code>onReady</code> will take view options as first arguments (or an empty object if view does not take any options).
          </p>
          <p>
            When view is not empty, Backbone Strap provide two helpers functions that can be used to initialize objects. Suppose that you want to render your view server side (and be good with google indexation), you may want to initialize your models or collections without fetching it again. All you have to do is to add objects values in DOM and read values:
<pre>
&lt;script type="text/javascript"&gt;
  window.$$model = {id: 1, name: 'foo'};
&lt;/script&gt;

// In your javascript files:
var view = new Backbone.StrapView({
  onInit: function() {
    this.model = new Backbone.StrapModel();

    // Ready model object from DOM.
    // - First argument is name of variable on window object
    // - Second argument is name of variable on view object
    //
    // Executed code out of the box is:
    //   this.model.set(window.$$model);
    //   delete window.$$model;
    this.$read('$$model', 'model');

    // Shortcut for:
    //   this.$read('$$model', 'model'); 
    this.$$read('model');
  };
});
</pre>
          </p>
          <p>
            <table class="table table-stripped table-bordered">
              <tbody>
                <tr>
                  <td><code>onInit</code></td>
                  <td>function</td>
                  <td>Initialization function called after original <code>initialize</code> function.</td>
                </tr>
                <tr>
                  <td><code>postInit</code></td>
                  <td>function</td>
                  <td>Initialization function called immediately after <code>onInit</code> callback when view is empty.</td>
                </tr>
                <tr>
                  <td><code>onReady</code></td>
                  <td>function</td>
                  <td>Initialization function called immediately after <code>onInit</code> callback when view is not empty.</td>
                </tr>
                <tr>
                  <td><code>$read</code></td>
                  <td>function</td>
                  <td>Read values from window object.</td>
                </tr>
                <tr>
                  <td><code>$$read</code></td>
                  <td>function</td>
                  <td>Read values from window object (shortcut for <code>$read</code> function).</td>
                </tr>
              </tbody>
            </table>
          </p>

          <h3>jQuery Cache</h3>
          <p>A jQuery cache is automatically managed on top of <code>Backbone.View.$</code> function.</p>
          <p>
            <table class="table table-stripped table-bordered">
              <tbody>
                <tr>
                  <td><code>$cache</code></td>
                  <td>property</td>
                  <td>Cache of jQuery objects (key is the selector, value is the jQuery object).</td>
                </tr>
                <tr>
                  <td><code>$c</code></td>
                  <td>function</td>
                  <td>Function used to retrieve jQuery objects from cache or DOM</td>
                </tr>
                <tr>
                  <td><code>$clear</code></td>
                  <td>function()</td>
                  <td>Function used to clear jQuery cache.</td>
                </tr>
              </tbody>
            </table>
<pre>
var $foo = view.$c('#foo');

// Second call will be retrieved from cache
var $bar = view.$c('#foo');

console.log($foo === $bar); // true
console.log(view.$cache);

view.$clear();
console.log(view.$cache);
</pre>
          </p>

          <h3>Subviews</h3>
          <p>
            Subviews can be stored in a dynamic map (key is the view cid, value is the view).
          </p>
          <p>
            <table class="table table-stripped table-bordered">
              <tbody>
                <tr>
                  <td><code>$subviews</code></td>
                  <td>property</td>
                  <td>Map of nested subviews.</td>
                </tr>
                 <tr>
                  <td><code>$addSubview</code></td>
                  <td>function</td>
                  <td>Add subview to the map of subviews from a DOM element.</td>
                </tr>
                <tr>
                  <td><code>addSubview</code></td>
                  <td>function</td>
                  <td>Add subview to the map of subviews.</td>
                </tr>
                <tr>
                  <td><code>removeSubview</code></td>
                  <td>function</td>
                  <td>Remove specific subview.</td>
                </tr>
                <tr>
                  <td><code>closeSubviews</code></td>
                  <td>function</td>
                  <td>Function used to close current subviews.</td>
                </tr>
              </tbody>
            </table>
          </p>
<pre>
var subview1 = new Backbone.StrapView();
var subview2 = new Backbone.StrapView();

var view = new Backbone.StrapView();

// Add subviews
view.addSubview(subview1);
view.addSubview(subview2);

// Remove first subview
view.removeSubview(subview1);

// Remove all subviews
view.closeSubviews();

// Add subview from DOM element
view.$addSubview(
  $('#bar'),           // - First parameter is the DOM element
  Backbone.StrapView,  // - Second parameter is the view class
  {}                   // - Third parameter is parameters given to the subview (optional)
);
</pre>

          <h3>Rendering</h3>
          <p>
            By default, views rendering is already implemented using:
            <ul>
              <li>Default template manager to fetch templates.</li>
              <li><code>toJSON</code> method is used to get view data</li>
              <li><code>templates</code> property / method is used to get view templates</li>
            </ul>
          </p>
          <p>
            <table class="table table-stripped table-bordered">
              <tbody>
                <tr>
                  <td><code>templates</code></td>
                  <td>property / function</td>
                  <td>View templates.</td>
                </tr>
                <tr>
                  <td><code>toJSON</code></td>
                  <td>property / function</td>
                  <td>View data used to populate view.</td>
                </tr>
                <tr>
                  <td><code>compileTemplate</code></td>
                  <td>function</td>
                  <td>
                    Function used to compile template using data (use underscore template function by default).<br>
                    This function is already and should not be overriden.
                  </td>
                </tr>
                <tr>
                  <td><code>toHtml</code></td>
                  <td>function</td>
                  <td>
                    Function used to serialize view as HTML (by default, use <code>compileTemplate</code>).
                    This function is already and should not be overriden.
                  </td>
                </tr>
                <tr>
                  <td><code>populate</code></td>
                  <td>function</td>
                  <td>
                    Build html views, i.e.:
                    <ul>
                      <li>Build html content (using <code>toHtml</code> function).</li>
                      <li>Close current subviews. Since html will be override, subviews must be destroyed to avoid memory leak.</li>
                      <li>Trigger <code>preRender</code> function (that can be used to execute code before rendering).</li>
                      <li>Clear view.</li>
                      <li>Add new html to <code>el</code> element.</li>
                      <li>Trigger <code>onReady</code> function (that can be used to execute code when view is rendered).</code>
                    </ul>
                  </td>
                </tr>
              </tbody>
            </table>
          </p>
<pre>
// Suppose that template foo is an underscore template equal to:
// &lt;div&gt;Id = &lt;%= obj.id %&gt;&lt;/div&gt;

var view = new Backbone.StrapView({
  templates: 'foo',
  toJSON: {
    obj: {
      id: 1
    }
  },
  el: '#foo'
});

view.render();

// Template 'foo' will be fetched and generated template will be:
// &lt;div&gt;Id = 1&lt;/div&gt;
</pre>

          <h3>Destruction</h3>
          <p>
            View can be closed / cleard and every event are automatically detached: you don't have to worry about memory management.
            <ul>
              <li>View stop to listen to model or collections events.</li>
              <li>jQuery events are detached.</li>
              <li>jQuery cache is destroyed.</li>
              <li>View content is removed (if close function is called, view $el object is also removed).</li>
              <li>Subviews are destroyed.</li>
              <li>Each view attributes is automatically destroyed to prevent memory leak.</li>
            </ul>
          </p>
          <p>
            <table class="table table-stripped table-bordered">
              <tbody>
                <tr>
                  <td><code>close</code></td>
                  <td>function</td>
                  <td>Close view and associated subviews.</td>
                </tr>
                 <tr>
                  <td><code>clear</code></td>
                  <td>function</td>
                  <td>Clear view (remove view content but <code>$el</code> is not removed) and close associated subviews.</td>
                </tr>
              </tbody>
            </table>
          </p>
        </div>
      </div>

      <div id="models" class="panel panel-default">
        <div class="panel-heading">Models</div>
        <div class="panel-body">
           <p>Backbone Strap provide new object <code>StrapModel</code> with new features.</p>
<pre>
var model = new Backbone.StrapModel({
  url: '/foo'
});
</pre>

          <div>
            <h3>Constructor</h3>
            <p>Parameter given during object initialization are automatically set on object.</p>
            <p>It means that you don't need <code>initialize</code> anymore !</p>
            <pre>
var model = new Backbone.StrapModel({
  foo: 'bar'
});

console.log(model.foo); // 'bar'
</pre>
            <h3>Sync Operations</h3>
            <p>Each sync methods (i.e. <code>fetch</code>, <code>save</code> and <code>destroy</code>) is overriden with new features:</p>
            <h4>> Complete Callback</h4>
            <p>A new callback can be added and will be called after <code>success</code> or <code>error</code> callback with same parameters</p>
<pre>
model.fetch({
  success: function() {
    console.log('on success');
  },
  error: function() {
    console.log('on error');
  },
  complete: function() {
    console.log('on complete, always called after success or error callback');
  }
});
</pre>

            <h4>> Sync Flags</h4>
            <p>When a sync method is called, a flag is set to <code>true</code>. It lets you know when a sync operation is in progress.</p>
            <ul>
              <li><code>$fetching</code> : Set to <code>true</code> / <code>false</code> if a fetch operation is in progress.
              <li><code>$saving</code> : Set to <code>true</code> / <code>false</code> if a save operation is in progress.
              <li><code>$destroying</code> : Set to <code>true</code> / <code>false</code> if a destroy operation is in progress.
            </ul>
<pre>
console.log(model.$fetching);    // false
model.fetch();
console.log(model.$fetching);    // true

console.log(model.$saving);      // false
model.save();
console.log(model.$saving);      // true

console.log(model.$destroying);  // false
model.destroy();
console.log(model.$destroying);  // true
</pre>

            <h4>> Simultaneous Calls</h4>
            <p>
              When a sync method is triggered, a second sync operation will not be executed until current operation is not completed. It will prevent simultaneous call (that can occur when a user click twice on a button).
              <br>
              Sync operation can be forced by passing <code>force</code> option to settings parameter.</p>
<pre>
// Fetch operation will be triggered only once
model.fetch();
model.fetch();

// Force fetch operation to be triggered even if last operation has not been completed
model.fetch({
  force: true
});
</pre>
          </div>
        </div>
      </div>

      <div id="collections" class="panel panel-default">
        <div class="panel-heading">Collections</div>
      </div>

    </div>

    <script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>

    <script>
      (function($) {
        var $menu = $('.navbar-nav li');
        $menu.on('click', function(e) {
          $menu.removeClass('active');
          $(e.currentTarget).addClass('active');
        });

        $('.panel-heading').on('click', function() {
          $(this)
            .toggleClass('off')
            .next().slideToggle('slow');
        });
      })(jQuery);
    </script>
  </body>
</html>